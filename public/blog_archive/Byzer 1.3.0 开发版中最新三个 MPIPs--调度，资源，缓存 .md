## Byzer 1.3.0 开发版中最新三个 MPIPs--调度，资源，缓存 

### 什么是 MPIP

MPIP 是新 Feature 提案。全称 Byzer Project Improvement Proposals 。当然这个是学习 Spark 的 SPIP，作为一个较为稳定成熟的项目，后续增加较大的功能特性会比较慎重，所以需要通过 Improvement Proposals 的方式来进行规范化，以后也方便回顾。

1.3.0 开发版最新的三个 MPIPs
在 Byzer 1.3.0 开发版中，我们根据实际场景需求，提出了三个 MPIPs:

```
MPIP-1031 表缓存功能
MPIP-1045 内置定时任务
MPIP-1047 资源动态调整
```
其中 1，3 已经完成了部分功能，并且合并进了 TRY 分支。大家可以通过比如名字 MPIP-1031 找到对应功能分支，看看开发的过程。

MPIP-1031 表缓存功能
Byzer 社区开发的一位同学打趣的说，在批，流，机器学习三大块，Byzer 已经覆盖批常规 99% 的功能了，但其实还远远没达到。 Spark 有一个很酷的功能，就是 cache，允许你把计算结果分布式缓存起来，但存在需要手动释放的问题。Byzer 认为要解决这个问题，需要将缓存的生命周期进行划分：

script
session
application

默认缓存的生命周期是 script。随着业务复杂度提高，一个脚本其实会比较复杂，在脚本中我们存在反复使用原始表或者中间表临时表的情况，这个时候我们可以通过 cache 实现原始表被缓存，中间表只需计算一次，然后脚本一旦执行完毕，就会自动释放。使用方式也极度简单：

```sql
select 1 as a as table1;
!cache table1 script;
select * from table1 as output;
```
session 级别暂时还没有实现。applicaton 级别则是和 Byzer Engine 的生命周期保持一致。需要手动释放：

```sql
!uncache table1;
```
表缓存功能极大的方便了用户使用 cache。对于内存无法放下的数据，系统会自动将多出来的部分缓存到磁盘。

MPIP-1045 内置定时任务
内置定时任务是完善 Byzer Stack 的一个重要环节。为用户提供一个更完整的服务。我们依然让这个工作 Byzer Style，使用方式简单，比如：

```sql
!crontab */5 * * * * self;

---you script content

select * from hive1 as hiveTable2;
save......
```
我们也期待未来能够加上脚本依赖的支持。

MPIP-1047 资源动态调整
当你在实际的生产环境使用 Byzer Stack 之后，大量的 Byzer Engine 会因为各种场景被部署： 有共分析师，业务探索使用的，有供作为 API 使用的，有做 ETL 引擎使用的，有做流使用的，有做机器学习平台使用的，这对服务提供方带来了大量的资源压力。比如业务探索类的，典型的上班时间资源需求大，下班时间基本上没怎么有人用，ETL 则是反之，API 也有一定方位。而且业务探索类的其实对响应有一定的实时需求，比如一个复杂的脚本使用者期待10s内返回，如果使用 Spark 的 DRA 反复的资源释放和申请，可能临时申请资源的时间就已经超过 10s，更不用提计算了。 这个时候我们更希望的是通过统计分析，自己制定一个资源调整策略，从而节省系统资源，减轻压力。Byzer 为此提出这个 MPIP,管理员只要通过简单的两个三个命令就可以添加或者删除 CPU/内存资源。

```
!resource add 10c;
!resource remove 10c;
!resource set 40c;
```

第一个表示给当前正在运行的 Byzer Engine 添加 10 个核，第二个表示减少 10 核，第三个则表示将当前的 Byzer Engine 的资源设置为 40 核。

那么内存呢？内存会根据启动时配置的 CPU 和内存的比例，进行相应的增加或者删减。比如我们启动时，CPU 和内存为 1:4，那么我们添加 10c，相应的，系统会自动增加 40G 的内存。

有了这个功能后，我们完全可以开发一个资源控制策略，对于探索类应用，每天上班时，自动增加资源，下班时剔除资源，用户也可以主动向管理员临时申请更多资源，实现真正的弹性，整个过程无需重启。

### 总结
Byzer 会越来越多的考虑用户场景来提供更多功能。
