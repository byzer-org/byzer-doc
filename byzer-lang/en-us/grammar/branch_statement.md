# Branch/If|Else

Similar to traditional programming languages, Byzer-Lang has variables, macro functions, and branch statement structures.

## Basic usage

Below is one of the simplest branch syntax:

```sql
set a = "wow,jack";
!if ''' split(:a,",")[0] == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;
```

`!if/!else` are not Byzer-Lang keywords, they are [macro functions](/byzer-lang/en-us/grammar/macro.md). The call of macro functions is similar to the command line so the learning threshold is quite low.

In the above example, we obtain variable `a` via variable declaration. Then the macro function `!if` only accepts one positional parameter. It is a macro function so a semicolon must be added at the end of the call `;` .

`!if` is followed by a text parameter whose content is an expression. All functions supported by Spark SQL can be used in expressions. The above example is the `split` function.

Functions registered with the register statement can be used in expressions. We will provide relevant examples in the latter part of the article.

The conditional expression uses `:` to identify a variable. The variable is derived from the [set statement](/byzer-lang/en-us/grammar/set.md). In the example, the value of the variable `:a` in the expression is `wow,jack`.

If the expression is:

```sql
split(:a,",")[0] == "jack"
```

If  `true` is returned , it will execute:

```sql
select 1 as a as b;
```

This `select` statement will generate a temporary table `b` through `as syntax`. This table has only one `a` field and the value is `1`.

If `false` is returned, it will execute:

```
select 2 as a as b;
```

This `select` statement will generate a temporary table `b` through `as syntax`. This table has only one `a` field and the value is `2`.

The sample code outputs the `b` table with the following statement:

```sql
select * from b as output;
```

From the above example, we can see that Byzer-Lang's conditional judgment statement has the following features:

1. The syntax design follows some SQL principles. For example, it uses `and/or` instead of `&&/||`. And use the `select` statement for variable assignment.
2. It is compatible with Spark SQL functions.
3. Support user-defined functions (see the latter half of the article).

## Branch statement nesting

Byzer-Lang also supports nesting of branch statements.

Example:

```sql
set a="jack,2";

!if ''' select split(:a,",")[0] as :name, split(:a,",")[1] as :num;
:name == "jack" and :num == 3
''';
    select 0 as a as b;
!elif ''' select split(:a,",")[1] as :num; :num==2 ''';
    !if ''' 2==1 ''';
       select 1.1 as a as b;
    !else;
       select 1.2 as a as b;
    !fi;
!else;
  select 2 as a as b;
!fi;


select * from b as output;
```

In the above code, the `!if` expression is more complicated:

```sql
!if ''' select split(:a,",")[0] as :name, split(:a,",")[1] as :num;
:name == "jack" and :num == 3
''';
```

Its difference from the first example is that there is an additional `select` syntax structure, which is as follows:


```sql
select split(:a,",")[0] as :name, split(:a,",")[1] as :num;
```

In the sample code above, two variables `:name` and `:num` are generated by `select`.

Then users can use `;` to split the different statements in the submitted expression. The second statement is to run the conditional expression on the two new variables:

```sql
:name == "jack" and :num == 3
```

Byzer-Lang will automatically convert the variable `:num` to a number during execution.

## Scope of variables in expressions

The variables declared in `!if/!elif` is valid in the entire `!if/!fi` interval. The substatement `!if/!else` can use the variables of the upper statement `!if/!else`.

Example:

```sql
set name = "jack";
!if '''select :name as :newname ;:name == "jack" ''';
    !if ''' :newname == "jack" ''';
       !println '''====1''';
    !else;
       !println '''====2 ''';
    !fi;
!else;
   !println '''=====3''';
!fi;
```

The output of this statement is `====1`, and the `newname` variable generated by the `select` of the upper statement `!if` is used in the substatement `!if`.

Similarly, users can also quote variables of the conditional expressions in the branch statements. For example:

```sql
set name = "jack";
!if '''select concat(:name,"dj") as :newname ;:name == "jack" ''';
    !if ''' :newname == "jackdj" ''';
       !println '''====${newname}''';
       select "${newname}" as a as b;
    !else;
       !println '''====2 ''';
    !fi;
!else;
   !println '''=====3''';
!fi;

select * from b as output;
```

In this example, in `select` and `!println` statement, users quoted variables declared in `!if` or `!elif` via `${}`.


## Combine the defaultParam variable

Conditional branch statements are combined with variable declaration syntax, which can be used in many scenarios.

Here we will introduce the scenario when it is combined with [defaultParam variable](/byzer-lang/en-us/grammar/set.md). 

For example:

```sql
set a = "wow,jack" where type="defaultParam";
!if ''' split(:a,",")[0] == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;

```

The output of the code is `2`. But if you add a statement in front of it:

```sql
set a = "jack,";
set a = "wow,jack" where type="defaultParam";
!if ''' split(:a,",")[0] == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;
```

This time its output is `1`. This means that users can add some variables in the first half of the script to overwrite the original variables during execution. Now we can control the script execution process more dynamically.


## Use customized functions in conditional expressions

As mentioned earlier, Byzer-Lang supports UDF. The registered UDF can also be used in conditional expressions in conditional branch statements.

Example:

```sql
register ScriptUDF.`` as title where
lang="scala"
and code='''def apply()={
   "jack"
}'''
and udfType="udf";

!if ''' title() == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;
```

## Lifecycle issues and solutions for tables in `!if/!else` sub-statements

In Byzer-Lang, the life cycle of a table is session-level. This means that in a session the table will be automatically registered in the system unless the table is deleted, redefined, or the session is invalid.
The session-level life cycle is mainly used with Notebook, to facilitate debugging. However, there are some problems when using `!if/!else` .

Consider the following example:

```sql
!if ''' 2==1 ''';
   select 1 as a as b;
!else;   
!fi;

select * from b as output;
```

When running for the first time, because `2==1` will return false, so the empty branch after `!else` will be executed. Then we quote `b`  for query again, the system will report an error because there is no table `b`.

So we change the following conditions and change from `2==1` to `1==1`. At this time, the system executes  `select 1 as a as b;` and  the `b` table is generated. The entire script runs normally.

Again, we modify `1==1` to `2==1`. At this point, the system outputs the same result of  the condition `1==1`. This is obviously not logical.

The reason is that the system remembers the last time when we ran  `b`. Although the `select` statement is not executed, there is still output, which causes an error.

There are two solutions:

1. Set request parameter `sessionPerRequest`, then the life cycle of each request table is `request`.
2. Add note  `set __table_name_cache__ = "false"` in the script; to let the system not to remember the table name. Logically, after the execution of each script, the system will automatically clean up the temporary table generated during the operation.

The second method is as follows:

```sql
set __table_name_cache__ = "false";
!if ''' 2==1 ''';
   select 1 as a as b;
!else;   
!fi;

select * from b as output;
```
