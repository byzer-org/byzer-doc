# Branch/If|Else

> Similar to traditional programming languages, Byzer-lang has variables, macro functions, and branch statement structures.

## Basic usage

An example of the simplest branch syntax:

```sql
set a = "wow,jack";
!if ''' split(:a,",")[0] == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;
```

`!if/!else` are not keywords in Byzer-lang. They are all [macro functions](/byzer-lang/en-us/grammar/macro.md). The call of macro functions is similar to the command line so the learning threshold is actually lower.

In the above example, a variable `a` is obtained through variable declaration. Then the macro function `!if` only accepts one positional parameter. It is a macro function so a semicolon must be added at the end of the call `;` .

`!if` is followed by a text parameter whose content is an expression. All functions supported by Spark SQL can be used in expressions. The above example is the `split` function.

Functions that are registered by using the register statement can be used in expressions. You can see the example in the later part of the article.

Use `:` in a conditional expression to identify a variable. The variable is derived from the [set statement](/byzer-lang/en-us/grammar/set.md). In the example, the value of the variable `:a` in the expression is `wow,jack`.

If the expression is:

```sql
split(:a,",")[0] == "jack"
```

Return true , then it will execute:

```sql
select 1 as a as b;
```

This `select` statement will generate a temporary table `b` through `as syntax`. This table has only one `a` field and the value is `1`.

Return false, then it will execute:

```
select 2 as a as b;
```

This `select` statement will generate a temporary table `b`through `as syntax`. This table has only one `a` field and the value is `2`.

The sample code finally outputs the `b` table with the following statement:

```sql
select * from b as output;
```

From the above example, we can see that Byzer-lang's conditional judgment statement has the following characteristics:

1. The syntax design follows some principles of SQL. For example, it uses `and/or` instead of `&&/||`. and use the `select` statement for variable assignment
2. Compatible with Spark SQL functions
3. Support user-defined functions (see the latter half of the article)

## Branch statement nesting

Byzer-lang also supports nesting of branch statements.

Example:

```sql
set a="jack,2";

!if ''' select split(:a,",")[0] as :name, split(:a,",")[1] as :num;
:name == "jack" and :num == 3
''';
    select 0 as a as b;
!elif ''' select split(:a,",")[1] as :num; :num==2 ''';
    !if ''' 2==1 ''';
       select 1.1 as a as b;
    !else;
       select 1.2 as a as b;
    !fi;
!else;
  select 2 as a as b;
!fi;


select * from b as output;
```

In the above code, the `!if` expression is more complicated:

```sql
!if ''' select split(:a,",")[0] as :name, split(:a,",")[1] as :num;
:name == "jack" and :num == 3
''';
```

The difference from the first example is that there is an additional `select` syntax structure, which is as follows:


```sql
select split(:a,",")[0] as :name, split(:a,",")[1] as :num;
```

In the sample code above, two variables `:name` and `:num` are generated by `select` .

Then users can use `;` to split the different statements that submit the expression. The second statement is to run the conditional expression on the two new variables:

```sql
:name == "jack" and :num == 3
```

Byzer-lang will automatically convert the variable `:num` to a number during execution time.

## Scope of variables in expressions

The scope of variables that is declared in `!if/!elif` is the entire `!if/!fi` interval. The substatement `!if/!else` can see the variables of the upper statement `!if/!else`.

Example:

```sql
set name = "jack";
!if '''select :name as :newname ;:name == "jack" ''';
    !if ''' :newname == "jack" ''';
       !println '''====1''';
    !else;
       !println '''====2 ''';
    !fi;
!else;
   !println '''=====3''';
!fi;
```

The output of this statement is `====1`, and the `newname` variable generated by the `select` in the upper statement `!if` is used in the substatement `!if`.

Similarly, in code of branch statements, users can also reference variables of conditional expressions. For example:

```sql
set name = "jack";
!if '''select concat(:name,"dj") as :newname ;:name == "jack" ''';
    !if ''' :newname == "jackdj" ''';
       !println '''====${newname}''';
       select "${newname}" as a as b;
    !else;
       !println '''====2 ''';
    !fi;
!else;
   !println '''=====3''';
!fi;

select * from b as output;
```

In this example, in `select` and `!println` statement, users reference variables declared in `!if` or `!elif` through `${}`.


## Combine the defaultParam variable

Conditional branch statements combined with variable declaration syntax can actually do a lot of interesting things.

Here we mainly introduce the combination with [defaultParam variable](/byzer-lang/en-us/grammar/set.md)and branch statements.

For example:

```sql
set a = "wow,jack" where type="defaultParam";
!if ''' split(:a,",")[0] == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;

```

The output of the code is `2`. But if you add a statement in front of it:

```sql
set a = "jack,";
set a = "wow,jack" where type="defaultParam";
!if ''' split(:a,",")[0] == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;
```

This time its output is `1`. This means that users can add some variables in the first half of the script overwrite the original variables during execution. This can control the script execution process dynamically.


## Use custom functions in conditional expressions

As mentioned earlier, Byzer-lang supports UDF. The registered UDF can also be used in conditional expressions in conditional branch statements.

Example:

```sql
register ScriptUDF.`` as title where
lang="scala"
and code='''def apply()={
   "jack"
}'''
and udfType="udf";

!if ''' title() == "jack" ''';
   select 1 as a as b;
!else;
   select 2 as a as b;
!fi;

select * from b as output;
```

## Lifecycle issues and solutions for tables in sub-statements !if/!else

In Byzer-lang, the life cycle of a table is session level. This means that in a session the table will be automatically registered in the system unless the table is deleted or redefined or the session is invalid.
The session-level life cycle is mainly used with Notebook, which is convenient for users to debug. However, there are some problems when using `!if/!else` .

Consider the following example:

```sql
!if ''' 2==1 ''';
   select 1 as a as b;
!else;   
!fi;

select * from b as output;
```

When running for the first time, `2==1` will return false so the empty branch after `!else` will be executed. Then we refer to `b` to query, the system will report an error because there is no table `b`.

So we modify the following conditions and change `2==1` to `1==1`. At this time, the system executes  `select 1 as a as b;` and  the `b` table is generated. The entire script runs normally.

Again, we modify `1==1` to `2==1`. At this point, the system outputs the same result of  the condition `1==1`. This is obviously not logical.

The reason is that the system remembers the last run `b`. Although the `select` statement is not executed, there is still output, which causes an error.

There are two solutions:

1. Request parameter setting: `sessionPerRequest`, then the life cycle of each request table is `request`.
2. Note `set __table_name_cache__ = "false" in the script;` to let the system not to remember the table name. Logically, after each script is executed, the system will automatically clean up the temporary table generated during the operation.

The second method is as follows:

```sql
set __table_name_cache__ = "false";
!if ''' 2==1 ''';
   select 1 as a as b;
!else;   
!fi;

select * from b as output;
```
