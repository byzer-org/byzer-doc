## Variable/Set

Byzer-lang supports variables.

## Basic application

```sql
set hello="world";
```

At this point, there will be no output result after users run it.

You can view this variable with the `select` statement.

Example:

```sql

set hello="world";

select "hello ${hello}" as title
as output;
```

The result is as follows:


```
title

hello world
```

In general, variables can be used in any part of any statement. It can even be the output table name.

Example:


```sql

set hello="world";

select "hello William" as title
as `${hello}`;

select * from world as output;
```

In the above code, the `world` table is not explicitly defined, but users can still use the `world` table in the `select` statement.

> Note: table names need to be enclosed in backticks to avoid parsing errors.

### life cycle

The current life cycle of the `set` syntax is at the `request` level. It means it is valid for each request.

Usually in Byzer-lang, the life cycle is divided into three parts:

1. request (the current execution request is valid)
2. session (the current session cycle is valid)
3. application (global application is vaild)


What does the `request` level mean? If you execute first:

```sql
set hello="world";
```

Then execute the code below separately:

```sql
select "hello William" as title
as `${hello}`;

select * from world as output;
```

The system will prompt an error:

```
Illegal repetition near index 17
((?i)as)[\s|\n]+`${hello}`
                 ^
java.util.regex.PatternSyntaxException: Illegal repetition near index 17
((?i)as)[\s|\n]+`${hello}`
                 ^
java.util.regex.Pattern.error(Pattern.java:1955)
java.util.regex.Pattern.closure(Pattern.java:3157)
java.util.regex.Pattern.sequence(Pattern.java:2134)
java.util.regex.Pattern.expr(Pattern.java:1996)
java.util.regex.Pattern.compile(Pattern.java:1696)
java.util.regex.Pattern.<init>(Pattern.java:1351)
java.util.regex.Pattern.compile(Pattern.java:1028)
java.lang.String.replaceAll(String.java:2223)
tech.mlsql.dsl.adaptor.SelectAdaptor.analyze(SelectAdaptor.scala:49)
```

The system cannot find the variable ${hello}, and then still outputs it. Finally this results in a syntax parsing error.

If you want the variable to be available across cells (in Notebook), you can set it as follows.

```sql
set hello="abc" where scope="session";
```

The default life cycle of the variable is `request`. It means it is valid in the current script or the current cell.


## Variable type

Byzer-lang's variables has five types:

1. text
2. conf
3. shell
4. sql
5. defaultParam

Text: the variable type of most of the code demonstrated earlier is text.

Example:

```sql
set hello="world";
```

Conf: it is a configuration option and usually used to configure the behavior of the system. 

Example:

```sql
set spark.sql.shuffle.partitions=200 where type="conf";
```

This variable indicates that the default number of partitions for shuffle of the underlying Spark engine is set to 200.


Shell: the key after `set` is finally generated by the shell.

> It is not recommended to use this method because the security risk is high.

Example:

```sql
set date=`date` where type="shell";
select "${date}" as dt as output;
```
Note: the command needs to be enclosed in backticks here.

The output is as follows:

```sql
dt

Mon Aug 19 10:28:10 CST 2019
```

`sql`: the key after `set` is finally generated by the sql engine. The following example shows its characteristics and usage:

```sql
set date=`select date_sub(CAST(current_timestamp() as DATE), 1) as dt`
where type="sql";

select "${date}" as dt as output;
```

Note: the command needs to be enclosed in backticks here. The final output is as follows:

```
dt

2019-08-18
```

defaultParam

Example:

```sql
set hello="foo";
set hello="bar";

select "${hello}" as name as output;
```

The output is as follows:

```
name

bar
```

In the example above, ''foo'' can be overwritten by ''bar''. To avoid this, Byzer-lang introduces `defaultParam`:

```sql
set hello="foo";
set hello="bar" where type="defaultParam";

select "${hello}" as name as output;
```

The final output is:

```
name

foo
```

If `hello="foo"` has not been set before,


```sql
set hello="bar" where type="defaultParam";

select "${hello}" as name as output;
```

Then the output result is:

```
name

bar
```

## Compile-time and runtime variables

Byzer-lang has a very complete permission system, which can easily control data source access to the column level, and proposes permissions for preprocessing. It means to complete the verification of table-level permissions by statically analyzing Byzer-lang scripts (the verification of column-level still needs to be completed at runtime).

But during preprocessing, the biggest challenge of permissions is the parsing of `set` variables. For example:

```sql
select "foo" as foo as foo_table;
set hello=`select foo from foo_table` where type="sql";
select "${hello}" as name as output;
```

If the first statement is not executed,  the second `set` statement will report an error during preprocessing. Because there is no table called `foo_table` at this time.

To solve this problem, Byzer-lang introduces two modes `compile/runtime`. If users want to evaluate the value in the `set` statement preprocessing stage, then users can add this parameter.

```sql
set hello=`select 1 as foo ` where type="sql" and mode="compile";
```

If you want the `set` variable to be executed only at runtime, you can set it to `runtime`:

```sql
set hello=`select 1 as foo ` where type="sql" and mode="runtime";
```

At this point, Byzer-lang does not create this variable in the preprocessing phase.


## Built-in variable

Byzer-lang provides some built-in variables. 

Example:

```sql
set jack='''
 hello today is:${date.toString("yyyyMMdd")}
''';
```

`date` is built-in and you can use it to implement date processing.
