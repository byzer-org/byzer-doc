## Variable/Set

Byzer-lang supports variables.

## Use case

```sql
set hello="world";
```

At this point, there will be no output after users run it.

You can view this variable with the `select` statement.

Example:

```sql

set hello="world";

select "hello ${hello}" as title
as output;
```

The result is as follows:


```
title

hello world
```

In general, variables can be used in any statement. It can even be the output table name.

Example:


```sql

set hello="world";

select "hello William" as title
as `${hello}`;

select * from world as output;
```

In the above code, the `world` table is not explicitly defined, but users can still use the `world` table in the `select` statement.

> Note: table names need to be enclosed in backticks to avoid parsing errors.

### Life cycle

The current life cycle of the `set` syntax is at the `request` level. It means it is valid only for each request.

Usually, in Byzer-Lang, the life cycle is divided into three parts:

1. request (valid only for the current execution request)
2. session (valid only for the current session)
3. application (valid globally)


What does the `request` level mean? If you execute:

```sql
set hello="world";
```

Then execute the code below separately:

```sql
select "hello William" as title
as `${hello}`;

select * from world as output;
```

The system will prompt an error:

```
Illegal repetition near index 17
((?i)as)[\s|\n]+`${hello}`
                 ^
java.util.regex.PatternSyntaxException: Illegal repetition near index 17
((?i)as)[\s|\n]+`${hello}`
                 ^
java.util.regex.Pattern.error(Pattern.java:1955)
java.util.regex.Pattern.closure(Pattern.java:3157)
java.util.regex.Pattern.sequence(Pattern.java:2134)
java.util.regex.Pattern.expr(Pattern.java:1996)
java.util.regex.Pattern.compile(Pattern.java:1696)
java.util.regex.Pattern.<init>(Pattern.java:1351)
java.util.regex.Pattern.compile(Pattern.java:1028)
java.lang.String.replaceAll(String.java:2223)
tech.mlsql.dsl.adaptor.SelectAdaptor.analyze(SelectAdaptor.scala:49)
```

The system cannot find the variable `${hello} or output it. And returns a syntax parsing error.

If you want the variable to be available across cells (in Notebook), you can set it as follows.

```sql
set hello="abc" where scope="session";
```

The default life cycle of the variable is `request`. It means it is valid in the current script or the current cell.


## Variable types

Byzer-Lang variables are in five types:

1. text
2. conf
3. shell
4. sql
5. defaultParam

Text: The variables in the code demonstrated earlier mostly belong to this type.

Example:

```sql
set hello="world";
```

Conf: It is a configuration option and is usually for configuring system behaviors. 

Example:

```sql
set spark.sql.shuffle.partitions=200 where type="conf";
```

This variable indicates that the default partition number for shuffle in the underlying Spark engine is set to 200.


Shell: The key after `set` is generated by the shell.

> It is not recommended to use this method because the security risk is high.

Example:

```sql
set date=`date` where type="shell";
select "${date}" as dt as output;
```
Note: the command needs to be enclosed in backticks here.

The output is as follows:

```sql
dt

Mon Aug 19 10:28:10 CST 2019
```

`sql`: The key after `set` is finally generated by the SQL engine. The following example shows its features and use cases:

```sql
set date=`select date_sub(CAST(current_timestamp() as DATE), 1) as dt`
where type="sql";

select "${date}" as dt as output;
```

Note: The command needs to be enclosed in backticks. The final output is as follows:

```
dt

2019-08-18
```

defaultParam

Example:

```sql
set hello="foo";
set hello="bar";

select "${hello}" as name as output;
```

The output is as follows:

```
name

bar
```

In the example above, `foo` will be overwritten by `bar`. To avoid this, Byzer-lang introduces `defaultParam`:

```sql
set hello="foo";
set hello="bar" where type="defaultParam";

select "${hello}" as name as output;
```

The final output is:

```
name

foo
```

If `hello="foo"` has not been set before,


```sql
set hello="bar" where type="defaultParam";

select "${hello}" as name as output;
```

Then the output result is:

```
name

bar
```

## Compile-time and runtime variables

Byzer-Lang has a comprehensive permission system to support column-level access control for data sources. And It also supports permissions for preprocessing. It means to complete the verification of table-level permissions with static analysis of Byzer-Lang scripts (the verification of column-level still needs to be done with runtime).

But the biggest challenge of permissions in preprocessing is the parsing of `set` variables. For example:

```sql
select "foo" as foo as foo_table;
set hello=`select foo from foo_table` where type="sql";
select "${hello}" as name as output;
```

If the first statement is not executed,  the second `set` statement will report an error during preprocessing. Because there is no table called `foo_table` at this time.

To solve this problem, Byzer-Lang introduces two modes `compile/runtime`. Users can add this parameter if they want to evaluate the value in the `set` statement preprocessing stage. 

```sql
set hello=`select 1 as foo ` where type="sql" and mode="compile";
```

If you want the `set` variable to be executed only at runtime, you can set it to `runtime`:

```sql
set hello=`select 1 as foo ` where type="sql" and mode="runtime";
```

Then Byzer-Lang will not create this variable in the preprocessing phase.


## Built-in variables

Byzer-lang provides some built-in variables. 

Example:

```sql
set jack='''
 hello today is:${date.toString("yyyyMMdd")}
''';
```

`date` is a built-in variable that can be used to implement date processing.
